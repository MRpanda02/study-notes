# C++随笔

1. ### 右移运算符

如果符号位为1，则右移时补充1，反之则补充0。

2. ### sizeof

作用：求某一个变量或某一种数据类型的变量占用内存的字节数：

用法1:

sizeof(变量名)

用法2:

sizeof(类型名)

### 3. 引用（相当于C指针）用于函数之间参数的传递

==定义：引用就是某个目标变量的“别名”（alias）==

前面加const,即为“常引用”

不能通过常引用修改其引用的内容，必须用源变量去修改

> const T或const T & 类型的引用不能用来初始化T&类型的引用，除非进行强制类型转换；反向可以

引用作为函数的返回值

```c++
int n=4;
int & SetValue()
{
    return n;			//返回对n的引用
}
int main()
{
    SetValue() = 40;      //返回值是引用的函数调用表达式，可以作为左值使用
    cout << n << endl;    //40
    int &r = SetValue()
    cout << r << endl;     //40
   	return 0;
}
```



1. ### 常量指针

 不可通过常量指针修改其指向的内容（1）和其引用的变量（2）

```c++
int n,m;
const int * p =&n;
*p = 5;  //编译出错（1）
p = 5; //编译出错（2）
n = 4;   //ok
p= &m;  //ok,常量指针的指向可以变化
```

> 和上述的引用类似，不能把常量指针赋值给非常量指针，除非进行强制转换；反过来可以

`函数参数为常量指针时，可避免函数内部不小心改变参数指针所指向地点的内容`

不能修改行为本身，但可以改变其目标

5. ### 动态内存分配(用new)

用法1:分配一个变量

P = new 类型名;

P是类型为T*的指针

动态分配出sizeof(T)大小字节的内存空间，并且将该内存空间的起始地址赋给P

用法2:分配一个数组

P = new T[N];

T：任意类型名

P：类型为T*的指针

N：要分配的数组元素的个数，可以是整形表达式

动态分配出sizeof(T)*N大小字节的内存空间，并且将该内存空间的起始地址赋给P

6. 动态内存释放(用delete)

```c++
delete 指针;    //该指针必须指向new出来的空间

int *p = new int;
* p =5;
delete p;
delete p;    //异常，一片空间不能被delete多次
```

7. freopen 方便调用程序

```c++
//每次运行程序输入的数据多时，减少麻烦
#include <iostream>
using namespace std;
int main()
{
    freopen("c:\\adsf\\safds\\test.txt","r",stdin);
    int n;
    cin >> n;
    while(n --)
    {
        int a,b;
        cin>>a>>b;
        cout << (a>b?a:b) <<endl;
    }
}
```

8. 内联函数(内联函数应该只是很简单的，执行很快的几条语句，否则得不偿失)

说明：因为在调用普通函数时，需要重新给形参和局部变量开辟空间，将实参的值复制给形参，还需要将函数的返回地址放入栈中，耗费时间多。用内联函数可以直接将整个函数体的代码插入地调用语句处。

> 但很显然，使用内联函数比使用普通函数会使最终可执行程序的体积增加，以时间换取空间或增加空间消耗来节省空间，这本是计算机学科中常用的方法。
>
> **且内联函数必须在使用之前定义完成，不能只出现内联函数的声明。

9. 函数的重载

C++允许多个函数取相同的名字，只要参数表不同即可，这称为函数的重载(overload)。

10. ## string 字符串类型（优先考虑）

为了防止数组越界而用的一个类。

体积是固定的，在不同编译器上不相同，并不会直接存放字符串，字符串会在别处开辟内存空间存放，string对象只存放该内存空间的地址或其他一些信息。（类似指针）

1.1 string对象之可以用比较运算符进行比较，也可以用算法运算符进行相加，相当于连接。

比较大小时，是按词典顺序比较，而且大小写相关。（ASCII码）

10. ### 数组作为函数的参数

不用写出数组的元素个数，数组作为函数参数时，是传引用的，即形参是实参的引用。

**二维数组作为参数时，必须要写明数组有多少列。

==srand用来设置种子，rand用来生成随机数==

12. 数组越界后果严重（编译器之间有差异）

13. strcmp(str1,str2).   用于比较小两个字符串，相同则返回0，str1<str2，返回负数，str1>str2,返回正数。
14. strlen用于求字符串长度。
15. strcat(str1,str2). 把str2接到str1后面
16. strupr(s1);  变成大写
17. strcpy的参数是是按位替换。
18. cin.getline(char buf[],int bufSize); 

功能：将用户从键盘输入的一整行，当作一个字符串读如到内存缓冲区buf中，并在末尾自动添加'\0'，但只会读入bufSize - 1个字符。

# 2. 指针

T *p

指针的作用：给予了我们自由访问内存空间的手段，通过指针程序能够访问的内存区域不再局限于变量锁占据的数据区域了，存放程序指令的指令去，别的程序的数据区，指令区，甚至操作系统的数据区和指令区都可以被程序访问和修改。

  变量P就是一个指针变量，P的类型是T*，表达式“*P”的类型是T，而通过表达式“*P”，就可以读写从地址P开始的sizeof(T)个字节。（即"\*p"等价于存放在p处的一个T类型的变量。

2.1指针运算

（1）两个同类型的指针可以比较大小。

（2）两个同类型的指针可以相减相加。

p2 - p1 = (地址2 - 地址1)/sizeof(T)

p1 + n = 地址p1 + n*sizeof(T) 

（3）指针变量可以加减一个证书类型变量或常量。

（4）可自增自减。

（5）p[n] = "*(p+n)"

2.2 空指针

在C++语言中，可以用”NULL“关键字对任何类型的指针进行赋值。值为NULL的指针，被称作空指针。空指针指向地址0。

2.3 指针作为函数参数

```c++
//(1)
void swap(int * p1,int * p2){}
int main()
{
    int m=3,n=4;
    swap(&m,&n);            //此时p1指向了m,p2指向了n，所以通过调用函数和一改变实参，但仍然是传值的方式
}

//(2)
void swap(int * p1,int * p2){}
int main()
{
    int m=3,n=4;
    int *pm = &m;
    int *pn = &n;
    swap(&pm,&pn);         //此时p1,p2和pm,pn没有联系，前者只是后者的拷贝,故不会改变实参和指向的变量
}
    
```

2.4 常量指针

Const T *p;

区别在于不能通过常量指针区修改其指向的内容。

2.5 字符串和指针

字符串常量和字符数组名的类型都是 char *,因此可以用它们给char *赋值。

2.6 string对象和char *指针的关系

可以用 char *类型的指针对string进行赋值。

string对象有一下成员函数：

const char *c_str();

该成员返回指向string对象中的字符串的指针，也是以"\0"结尾，返回的指针是const的，所以不能通过该指针去修改string对象中的

字符串的内容。

```c++
const char *p = s.c_str();
//如果s的内容发生了改变，则p指针很可能不再有效，因为s内容的改变意味着存放s中字符串的内存空间的地址可能已经变了。
```

2.7 void指针

可以用任何类型的指针对void指针进行赋值或初始化。但是由于sizeof(void)没有定义，所以对于 void *类型的指针p,表达式"\*p"也没有定义，不能进行指针运算。

主要用于内存复制，将内存中某一块的内容复制到另一块中，那么源块和目的块的地址就都可以用void指针表示。

在cstring头文件中的库函数：

void * memset(void *dest,int ch,int n);

```c++
int a[100];
memset(a,0,sizeof(a));
//数组a的每个元素都变成0
```



将从dest开始的n个字节，都设置成ch,返回值是dest,ch虽然是整形，但只有最低字节是起作用的。

void *memcpy(void *dest,void *src,int n);

将地址src开始的n个字节，复制到地址dest，返回值是dest。

```c++
int a1[10];
int a2[10];
memcpy(a2,a1,10 * sizeof(int));
//将数组a1的内容复制到数组a2中去
```

2.8 函数指针

定义：每个函数都会占用一段连续的内存空间，函数名则代表起始位置（“入口地址”），可以将函数体的入口地址赋给一个指针变量，是该指针变量指向该函数，然后通过指针变量就可以调用这个函数。

一般形式：

类型名 （* 指针变量名)(参数类型1,....);

可以用一个原形匹配的函数的名字给一个函数指针赋值。

```c++
coid PrintMin(int a,int b)
{
    if(a<b)
        cout << a;
    else
        cout << b;
}
int main()
{
    void (* pt)(int,int);
    int x=4,y=5;
    pf = PrintMin();
    pf(x,y);
    return 0;
}
```

应用：

C++中有一个快速排序的标准库函数qsort,在cstdlib中声明

void sort(void * base,int nelem,unsigned width,int(*pfCompare)(const void *,const void *));

该函数可以对任何类型的一维数组排序。

base:待排序数组的每个元素的大小（字节）

pfCompare:函数指针，指向一个“比较函数”

过程：排序就是一个不断比较元素，并交换元素位置的过程。qsort在执行期间，会以这两个元素的地址作为参数，通过pfCompare指针调用一个“比较函数”，根据“比较函数”的返回值来判断两个元素哪个更应该排在前面。

qsort函数的用法规定，“比较函数”的原型应是：

int 函数名(const void *elem1,const void *elem2);

该函数必须具有一下行为：

(1) 如果 \*elem1应该排在\*elem2前面，则函数返回值是负整数（任何都🉑️）。

(2)如果\*elem1和\*elem2哪个排在前面都行，那么函数返回0。

(3)如果\*elem1应该排在\*elem2后面，则函数返回值是正整数（任何都🉑️）。

